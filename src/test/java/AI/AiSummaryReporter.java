package AI;

import io.qameta.allure.Allure;
import models.MongoConnector;
import models.ReportComparator;
import org.bson.Document;

import java.io.ByteArrayInputStream;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

public class AiSummaryReporter {

    private static final String projectName = System.getProperty("project.name",
            System.getenv("PROJECT_NAME") != null ? System.getenv("PROJECT_NAME") : "AI-Allure-Reuse-luffy-master");

    public static void logSummary() {
        StringBuilder finalSummary = new StringBuilder();

        try {
            ReportComparator.compareLatestExecutions();

            var db = MongoConnector.connect();
            var collection = db.getCollection("ai_executions");

            List<Document> projectDocs = collection.find(new Document("project", projectName))
                    .into(new ArrayList<>());

            if (projectDocs.isEmpty()) {
                finalSummary.append("‚ö†Ô∏è No execution data found for project: ").append(projectName);
            } else {
                finalSummary.append("<h3>üß† AI Execution Summary for Project: ").append(projectName).append("</h3>");
                finalSummary.append("<hr>");

                Map<String, List<Document>> groupedBySubproject = projectDocs.stream()
                        .collect(Collectors.groupingBy(d -> d.getString("subproject")));

                double totalRate = 0.0;
                long totalEndpoints = 0;
                int countedProjects = 0;

                for (String subproject : groupedBySubproject.keySet()) {
                    List<Document> runs = groupedBySubproject.get(subproject);
                    runs.sort(Comparator.comparing(d -> d.getString("timestamp"), Comparator.reverseOrder()));

                    finalSummary.append("<h4>üì¶ Subproject: ").append(subproject).append("</h4>");

                    Document subDoc = runs.get(0);
                    List<Document> allSessions = (List<Document>) subDoc.getOrDefault("sessions", List.of());

                    if (allSessions.size() < 2) {
                        finalSummary.append("‚ö†Ô∏è Only one session found ‚Äî comparison unavailable.<br><br>");
                        continue;
                    }

                    allSessions.sort(Comparator.comparing(s -> s.getString("createdAt"), Comparator.reverseOrder()));

                    List<Document> latestSessions = List.of(allSessions.get(0));
                    List<Document> previousSessions = List.of(allSessions.get(1));

                    String subReport = compareSessions(
                            subproject,
                            allSessions.get(1).getString("createdAt"),
                            allSessions.get(0).getString("createdAt"),
                            previousSessions,
                            latestSessions
                    );
                    finalSummary.append(subReport).append("<br>");

                    long latestTotal = countEndpoints(latestSessions);
                    long latestSuccess = countSuccessEndpoints(latestSessions);
                    double latestRate = latestTotal == 0 ? 0 : (latestSuccess * 100.0 / latestTotal);

                    totalRate += latestRate;
                    totalEndpoints += latestTotal;
                    countedProjects++;
                }

                if (countedProjects > 0) {
                    double avgRate = totalRate / countedProjects;
                    finalSummary.append("<hr>");
                    finalSummary.append(String.format("""
                            <h3>üåç Global Project Comparison Summary</h3>
                            <p><b>üèÅ %s ‚Äî Avg Success Rate:</b> %.2f%% | <b>Endpoints:</b> %d</p>
                            """, projectName, avgRate, totalEndpoints));
                }

                finalSummary.append("<hr>");
                finalSummary.append("<p style='font-size:13px;color:#666;'>‚ú® Auto-generated by AI + Allure | Smart Project Comparison</p>");
            }

        } catch (Exception e) {
            finalSummary.append("‚ùå Error during report generation: ").append(e.getMessage());
            e.printStackTrace();
        }

        // ‚úÖ Add the Search Bar + Script inside the report
        String htmlReport = """
            <html>
            <head>
                <meta charset='UTF-8'>
                <style>
                    body { font-family:'Segoe UI',sans-serif;background:#f9fbfd;padding:20px; }
                    h2 { color:#0078D7; }
                    .card { background:#fff; border-radius:12px; padding:20px; margin-bottom:20px;
                            box-shadow:0 4px 10px rgba(0,0,0,0.08); }
                    input,button { font-size:14px; }
                </style>
            </head>
            <body>
                <h2>üìä AI Subproject Analysis ‚Äî %s</h2>

                <!-- üîç Search MongoDB Data -->
                <div class='card' style='border-left:6px solid #6C63FF;'>
                    <h3>üîç Search Historical AI Data</h3>
                    <input id='searchInput' type='text' placeholder='Search (e.g. login, error, endpoint)'
                        style='padding:8px;width:60%%;border-radius:8px;border:1px solid #ccc;'>
                    <button onclick='searchAIData()'
                        style='padding:8px 15px;background-color:#0078D7;color:white;border:none;border-radius:8px;margin-left:10px;'>
                        Search
                    </button>
                    <div id='searchResults' style='margin-top:20px;'></div>
                </div>

                <!-- üß† AI Summary -->
                <div class='card' style='border-left:6px solid #4285F4;'>%s</div>

                <script>
                async function searchAIData() {
                    const query = document.getElementById("searchInput").value.trim();
                    const resultsDiv = document.getElementById("searchResults");
                    if (!query) {
                        resultsDiv.innerHTML = "<p style='color:red;'>Please enter a search keyword.</p>";
                        return;
                    }
                    resultsDiv.innerHTML = "<p>‚è≥ Searching...</p>";
                    try {
                    const res = await fetch(`https://ai-reports-backend.onrender.com/api/search?q=${encodeURIComponent(query)}`);
                        if (!res.ok) throw new Error("Server not reachable");
                        const data = await res.json();

                        if (!data.results || Object.keys(data.results).length === 0) {
                            resultsDiv.innerHTML = "<p>No results found for <b>" + query + "</b>.</p>";
                            return;
                        }

                        let html = "";
                        for (const [collection, docs] of Object.entries(data.results)) {
                            html += `<h4 style='color:#0078D7;'>üìÇ ${collection}</h4>`;
                            if (docs.length === 0) {
                                html += "<p><i>No entries found.</i></p>";
                            } else {
                                docs.forEach(doc => {
                                    html += `<pre style='background:#f8f9fa;padding:10px;border-radius:6px;border:1px solid #ddd;'>${JSON.stringify(doc,null,2)}</pre>`;
                                });
                            }
                        }
                        resultsDiv.innerHTML = html;
                    } catch (err) {
                        resultsDiv.innerHTML = `<p style='color:red;'>‚ùå Failed to fetch data: ${err.message}</p>`;
                    }
                }
                </script>
            </body>
            </html>
            """.formatted(projectName, finalSummary.toString());

        Allure.addAttachment("AI Subproject Comparison (" + projectName + ")", "text/html",
                new ByteArrayInputStream(htmlReport.getBytes(StandardCharsets.UTF_8)), "html");

        System.out.println(htmlReport);
    }

    // ‚úÖ Helper methods remain unchanged
    private static String compareSessions(String subproject, String prevTime, String latestTime,
                                          List<Document> prevSessions, List<Document> latestSessions) {
        long prevTotal = countEndpoints(prevSessions);
        long latestTotal = countEndpoints(latestSessions);
        long prevSuccess = countSuccessEndpoints(prevSessions);
        long latestSuccess = countSuccessEndpoints(latestSessions);
        long prevFail = prevTotal - prevSuccess;
        long latestFail = latestTotal - latestSuccess;
        double prevRate = prevTotal == 0 ? 0 : (prevSuccess * 100.0 / prevTotal);
        double latestRate = latestTotal == 0 ? 0 : (latestSuccess * 100.0 / latestTotal);
        double diff = latestRate - prevRate;

        Set<String> prevEndpoints = extractEndpoints(prevSessions);
        Set<String> latestEndpoints = extractEndpoints(latestSessions);

        Set<String> added = new HashSet<>(latestEndpoints);
        added.removeAll(prevEndpoints);
        Set<String> removed = new HashSet<>(prevEndpoints);
        removed.removeAll(latestEndpoints);
        Set<String> prevFailed = extractFailedEndpoints(prevSessions);
        Set<String> latestFailed = extractFailedEndpoints(latestSessions);
        Set<String> newFails = new HashSet<>(latestFailed);
        newFails.removeAll(prevFailed);

        StringBuilder html = new StringBuilder();
        html.append(String.format("""
                <b>üß© Subproject:</b> %s<br>
                <b>üìÖ Previous Run:</b> %s ‚Äî %d endpoints<br>
                <b>üìÖ Latest Run:</b> %s ‚Äî %d endpoints<br>
                <b>üìä Comparison:</b><br>
                ‚Ä¢ Previous Success Rate: %.2f%% (%d/%d)<br>
                ‚Ä¢ Latest Success Rate: %.2f%% (%d/%d)<br>
                ‚Ä¢ Change: %+.2f%%<br>
                ‚Ä¢ Failures: %d ‚Üí %d<br><br>
                """, subproject, prevTime, prevTotal, latestTime, latestTotal,
                prevRate, prevSuccess, prevTotal, latestRate, latestSuccess, latestTotal, diff, prevFail, latestFail));

        if (!added.isEmpty()) added.forEach(ep -> html.append("‚ûï ").append(ep).append("<br>"));
        if (!removed.isEmpty()) removed.forEach(ep -> html.append("‚ûñ ").append(ep).append("<br>"));
        if (!newFails.isEmpty()) newFails.forEach(ep -> html.append("‚ùå ").append(ep).append("<br>"));
        if (added.isEmpty() && removed.isEmpty() && newFails.isEmpty()) html.append("‚úÖ Stable endpoints.<br>");

        return html.toString();
    }

    private static long countEndpoints(List<Document> sessions) {
        return sessions.stream()
                .mapToLong(s -> ((List<?>) s.getOrDefault("endpoints", List.of())).size())
                .sum();
    }

    private static long countSuccessEndpoints(List<Document> sessions) {
        return sessions.stream()
                .flatMap(s -> ((List<Document>) s.getOrDefault("endpoints", List.of())).stream())
                .filter(d -> {
                    int status = d.getInteger("status", 0);
                    return status >= 200 && status < 300;
                })
                .count();
    }

    private static Set<String> extractEndpoints(List<Document> sessions) {
        return sessions.stream()
                .flatMap(s -> ((List<Document>) s.getOrDefault("endpoints", List.of())).stream())
                .map(d -> d.getString("method") + " " + d.getString("endpoint"))
                .collect(Collectors.toSet());
    }

    private static Set<String> extractFailedEndpoints(List<Document> sessions) {
        return sessions.stream()
                .flatMap(s -> ((List<Document>) s.getOrDefault("endpoints", List.of())).stream())
                .filter(d -> d.getInteger("status", 0) >= 400)
                .map(d -> d.getString("method") + " " + d.getString("endpoint"))
                .collect(Collectors.toSet());
    }
}
